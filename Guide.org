#+title: Guide to Emacs: An Editor for a Lifetime
#+author: Jackson Ray Hamilton

* Making My Own Kitchen Sink

Emacs, and its packages, provide a more-or-less comprehensive suite of tools for editing text - and ultimately, for building projects and producing code.  However, it's not all plug-and-play; in this ecosystem, there are lots of settings you need to tweak and tools you need to discover, install, and master, in order to craft an experience that's best for you.  What you'll have by the end of your customization journey is a "kitchen sink" - a workspace in which you can effortlessly navigate codebases and maintain them.  That's what I feel I've achieved over the last decade+ of using Emacs.

What follows are all the tips and tricks I have for anyone who wants to learn and master this awesome tool.  Everything here you can copy into your own config file, which can be saved to: =~/.emacs.d/init.el=

A working config file implementing /all/ of this is also available in this directory; see "init.el"

* The Ins and Outs of My Configuration

** Theme and Appearance

Out-of-the-box, GUI builds of Emacs look hideous.  However, with a few simple steps, I believe Emacs can be made to look "cool:"

- Disable unnecessary UI elements, like the toolbar and scrollbar
- Configure a font that is both readable and beautiful
- Override the default theme with a stylish dark theme, incorporating iconography

For the font, I love Monaco on a Mac.  A size of "16" accomodates my failing eyesight.

The theme I've been satisfied with for the past few years has been =zerodark-theme=.  Note that you need to run the command =all-the-icons-install-fonts= (once) to install the iconography for =zerodark-theme= at the system level.

*** Config

#+BEGIN_SRC elisp
  (setq inhibit-splash-screen t)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)

  (defconst my-default-font
    (cond
     ((eq system-type 'darwin)
      "monaco 16")
     ((eq system-type 'windows-nt)
      "consolas 16")
     (t
      "monospace 16")))

  (set-frame-font my-default-font)
  (add-to-list 'default-frame-alist `(font . ,my-default-font))

  (load-theme 'zerodark t)
  (zerodark-setup-modeline-format)
#+END_SRC

** Standardization

I no longer use Emacs' (crazy) default keymap.  (The one described in the Emacs tutorial.)  It was fun to learn initially, but not to use regularly.  The rest of my OS uses "normal" bindings, and I believe my editor should behave the same.

Enabling =cua-mode= normalizes a few common editing shortcuts:

- =Ctrl+Z= to undo
- =Ctrl+X= to cut
- =Ctrl+C= to copy
- =Ctrl+V= to paste

The remaining shortcuts that I'd consider "standard" - and especially-useful for everyday editing - need to be configured manually:

- =Ctrl+A= to "select all"
- =Ctrl+O= to open files
- =Ctrl+B= to switch buffers (i.e. switch between files)
- =Ctrl+S= to save
- =Ctrl+W= to close a buffer (i.e. a file)
- =Ctrl+F= to search
- =Ctrl+R= to find and replace

*** Config

#+BEGIN_SRC elisp
  (cua-mode)

  (keymap-global-set "C-a" #'mark-whole-buffer)
  (keymap-global-set "C-o" #'find-file)
  (keymap-global-set "C-b" #'switch-to-buffer)
  (keymap-global-set "C-s" #'save-buffer)
  (keymap-global-set "C-w" #'kill-current-buffer)
  (keymap-global-set "C-f" #'isearch-forward)
  (keymap-global-set "C-r" #'query-replace)
#+END_SRC

It frustrates me that Emacs puts itself out-of-reach to anyone except highly-patient adepts willing to learn its strange default keymap, or else to those with the motivation to learn how to fix it.  Thankfully, it only takes a few lines of config to resolve this discomfort and make Emacs "feel like home."

Also, I recommend remapping your "Caps Lock" key to an additional =Ctrl= at the OS level.  It's a big, unimportant key, which is often a lot easier to press than the actual "Control" key on a keyboard, as far as all these keyboard shortcuts are concerned.

** Navigation

*** Buffers

To move around buffers (i.e. files), I alternate between the following methods:

- Trackpad/mouse
- The four arrow keys (sometimes with =Alt=, i.e. =Option= on Mac, to skip over words)
- =Alt+M= to jump to where indentation begins (usually more useful than beginning-of-line)
- =Ctrl+E= to jump to end-of-line
- =Alt+<= (i.e. =Alt+Shift+,=) to jump to beginning-of-file
- =Alt+>= (i.e. =Alt+Shift+.=) to jump to end-of-file
- =Ctrl+F=

Besides =Ctrl+F=, these are all default bindings - no config necessary.

*** Files

To open files, I alternate between the following methods:

- =Ctrl+B= to select an already-open file
- =Ctrl+O= to select a file from the filesystem
- =Ctrl+/= to list files (=ls -la=) and open from the list

Emacs offers a text-based, interactive view of your filesystem, similar to =ls -la= in Mac/Linux shells.  It's accessible via "Dired" using =dired-jump=, which I have bound to =Ctrl+/=.  (Mnemonic: "/" is the character used to denote "directory" in Mac/Linux, and you're "opening the directory.")

#+BEGIN_SRC elisp
  (keymap-global-set "C-/" #'dired-jump)
#+END_SRC

I prefer Dired to a "tree view" because I can focus on one directory at a time, then close the view.

As I use Emacs, I tend to have a large number of files open at a time.  Instead of managing tabs (neverending clutter), Emacs invisibly manages a list of my open files for me.  I allow my list of open files to grow for a while, and I use fuzzy matching to quickly narrow and select from this large list via a compact view, "Ido."

Ido ("interactive do") is a user-friendly interface that can be enabled for selecting files in Emacs.  It is enhanced by the packages =ido-completing-read+= (enabling Ido "everywhere" in Emacs) and =flx-ido= (enabling fuzzy matching).

#+BEGIN_SRC elisp
  (require 'ido)
  (ido-mode 1)
  (ido-everywhere 1)
  (ido-ubiquitous-mode 1)
  (flx-ido-mode 1)
  (setq ido-enable-flex-matching t)
  (setq ido-use-faces nil) ; disable ido faces to see flx highlights
  (setq gc-cons-threshold 20000000) ; recommended for better GC with flx
#+END_SRC

** Text Selection

In Emacs you can select text with your trackpad/mouse, or by setting mark with =Ctrl+SPACE= and moving point with keyboard commands to manually create a region.

There is also a package you can install called =expand-region= which can help you to automatically select text by semantic units.  I highly-recommend it as it takes much of the precision work out of selecting text.

- =Ctrl+== to create or expand a selection from your current position
- =Ctrl+PLUS= (i.e. =Ctrl+Shift+==) to contract selection

*** Config

#+BEGIN_SRC elisp
  (keymap-global-set "C-=" #'er/expand-region)
  (keymap-global-set "C-+" #'er/contract-region)
#+END_SRC

** Search

Often I want to search for additional instances of a bit of text that's in a file.  Here's some config to make it so that, if you use =Ctrl+F= while you have some text selected, then the selected text is what gets searched-for.  (Works really well with =expand-region=.)

#+BEGIN_SRC elisp
  (defun my-isearch-with-region ()
    "Use region as the isearch text."
    (when mark-active
      (let ((region (funcall region-extract-function nil)))
        (deactivate-mark)
        (isearch-push-state)
        (isearch-yank-string region))))

  (add-hook 'isearch-mode-hook #'my-isearch-with-region)
#+END_SRC

** Screen Splitting

Emacs has commands to "split screens," which it refers to as "windows."  I like to bind these to =Ctrl+NUMBER=:

- =Ctrl+0= to "minimize" the current window (likely maximizing another)
- =Ctrl+1= to maximize the current window (if there's a split)
- =Ctrl+2= to split vertically
- =Ctrl+3= to split horizontally

The mnemonic here is:

- =Ctrl+0=: "reduce to nothing (0)"
- =Ctrl+1=: "make it the only one (1)"
- =Ctrl+2=: "split it in two (2)"
- =Ctrl+3=: like =Ctrl+2=, but the "other" variant

You can split screens an arbitrary number of ways, but I usually either have a single window maximized at a time, or temporarily have the screen split into two parts vertically.  A horizontal split is occasionally more useful depending on the format of the documents you have open.

*** Config

#+BEGIN_SRC elisp
  (keymap-global-set "C-0" #'delete-window)
  (keymap-global-set "C-1" #'delete-other-windows)
  (keymap-global-set "C-2" #'split-window-below)
  (keymap-global-set "C-3" #'split-window-right)
#+END_SRC

** Quick Access Shortcuts

From =F5= through =F9=, Emacs provides no default bindings.  I decided to make this range of keys my "command center" for my most-frequently-used and most-powerful commands.

If you use a Mac, you can make it so you don't need to press =fn= to trigger your =F= keys, like normal.  I'd recommend enabling that setting, as the shortcuts will be much more ergonomic.

*** F5: Open Emacs Config File

Since the beauty of Emacs is in customizing the experience to your liking, you frequently find yourself opening and editing your config file.  I opened it so often that I decided to just dedicate a special key to it.  (Surprised?)

#+BEGIN_SRC elisp
  (defun my-find-configuration ()
    "Open the Emacs configuration file."
    (interactive)
    (find-file (concat user-emacs-directory "init.el")))

  (keymap-global-set "<f5>" #'my-find-configuration)
#+END_SRC

*** F6: Restart Emacs

Whenever you update your config file, you have the option to either manually evaluate the Lisp forms therein to apply the configuration changes directly to the current instance - OR, you can simply restart Emacs, and all the forms will be evaluated "freshly."  Often, testing configuration changes is easiest with a quick restart.

Emacs has a built-in command called =restart-emacs=, but I recommend installing the 3rd-party package with the same name.  It provides a version of the command that seems to work more reliably than the built-in one.

#+BEGIN_SRC elisp
  (require 'restart-emacs) ; load 3rd-party version

  (defun my-restart ()
    "Prompt whether to restart Emacs."
    (interactive)
    (when (y-or-n-p "Restart?")
      (restart-emacs)))

  (keymap-global-set "<f6>" #'my-restart)
#+END_SRC

*** F7: Git Interface

Emacs is blessed with a very powerful and user-friendly interface to Git called "Magit."  Magit makes working with Git much easier than the standard command-line interface, and without any noticeable sacrifices in functionality.  I consider Magit one of the most important tools in my toolbelt during a day dedicated to coding.

With Magit, all Git commands have 1-letter shortcuts, making them painless to invoke:

- =F7= to see changes and invoke other commands
- =TAB= to toggle diffs
- =s= to stage files/hunks
- =A= to cherry-pick
- =b= to branch
- =c= to commit
- =F= to pull
- =l= to view commit log
- =P= to push
- =r= to rebase
- =V= to revert
- =z= to stash

Magit can also be combined with Ido for easy access to all branch and tag names (for when you need to switch to them).  Use the package =magit-ido= for that integration.

#+BEGIN_SRC elisp
  (require 'magit)
  (require 'magit-ido)

  (keymap-global-set "<f7>" #'magit-status)
  (setq magit-completing-read-function #'magit-ido-completing-read)
#+END_SRC

*** F8: Project Management

When working on a software project, it's common to search for files and text within the scope of a project's root directory - as opposed to from the scope of the whole filesystem, or from miscellaneous subdirectories.  Sometimes you may also wish to "find and replace" across files in a project.

The Emacs package "Projectile" automatically detects the root directory of the project associated with any file you have open, and then it performs searches from there.  The package can also be configured to filter out uninteresting files/directories from searches; simply create a =.projectile= file in the project root, and list filename patterns to ignore.

I prefer Projectile's "dynamic project actions" to the model of "opening a project" seen in other editors.  Other editors lock you into editing one project per editor instance; however, in my experience, it's common to hop between projects, especially those that depend on each other.  Having a single editor instance to manage multiple projects at once feels convenient.

Like Magit, Projectile provides a suite of 1-letter shortcut keys to perform its various operations:

- =F8= to choose a project-based command
- =f= to find a file by name within the project
- =g= to search the project's files with Grep
- =r= to find and replace, interactively, file-by-file

#+BEGIN_SRC elisp
  (projectile-mode)

  (keymap-global-set "<f8>" #'projectile-commander)
#+END_SRC

*** F9: AI Assistant

All of Emacs' functionality aids programmers in the authorship of formal languages.  It remains important that there are tools available for exploring directories and examining files, as well as for precisely editing and quickly searching.

However, AI coding assistants have become impressively-capable of converting natural languages into code, massively reducing the levels of manual exploration, examination, editing, and searching required to create working applications.  It's becoming obvious to more and more developers that LLMs are one of the most convenient and powerful tools now available, in terms of understanding, planning, templating, and debugging.

Claude Code is my coding assistant of choice.  I was very happy with the results from Anthropic's Sonnet model, and Claude Code utilizes Sonnet beautifully.  I use it to write most of my code and to plan and implement most of the changes I make.  The integrations with Linear and Figma also enable the tool to automatically implement most product requirements as specified by my teammates at work.

I use =claude-code.el= (by Steve Molitor) in order to manage Claude Code instances inside Emacs on a per-project basis.  Like Magit and Projectile, =claude-code.el= provides a suite of 1-letter shortcut keys to help me interact with Claude Code:

- =F9= to choose a command
- =c= to start the assistant
- =t= to open and switch to the assistant's window
- =z= to enable "read-only" mode in the assistant window (navigate/select output)

#+BEGIN_SRC elisp
  (require 'claude-code)

  (setq claude-code-toggle-auto-select t)
  (setq claude-code-eat-read-only-mode-cursor-type '(bar nil nil))

  (keymap-global-set "<f9>" #'claude-code-transient)
#+END_SRC

*** Other Commands

All of Emacs' commands are available explicitly via =Alt+X=.  For any commands that couldn't fit into the command center, access them here.  Ido completion is available here via the =ido-completing-read+= package, but there is also a further enhancement available via the =amx= package, which will sort your most-used commands to the front of the completions, as well as display any keybindings for the listed commands.

#+BEGIN_SRC elisp
  (amx-mode 1)
#+END_SRC

** Coding with JavaScript/TypeScript

JavaScript and TypeScript are the languages I write the most code in.  My setup for those languages is the most-sophisticated and battle-tested one that I can showcase.

For the most-accurate syntax highlighting and indentation, as well as for features like jump-to-definition, I recommend using the Tree-sitter-powered =js-ts-mode= along with the TypeScript modes that are built-in to Emacs.

#+BEGIN_SRC elisp
  (add-to-list 'major-mode-remap-alist '(javascript-mode . js-ts-mode))

  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . tsx-ts-mode))
#+END_SRC

Tree-sitter was made to abstract-away many of the complexities that arise when an editor tries to parse code, which is often either half-written or containing patterns too complex to accurately match with regular expressions; this is why Emacs is "smartest" when using it.  Plus, Tree-sitter is compiled to native code, so these modes should be fast!

Once, you will need to install the grammars for each of these modes.  You will need a C/C++ compiler and linker installed in order to do this.  The following code will try to download and compile the grammars the first time you open Emacs.  If you run into errors, and want to try again, then either restart Emacs, or manually invoke the command =my-treesit-install-all-languages= (via =Alt+X=).

#+BEGIN_SRC elisp
  (require 'treesit)

  ;; (Compatible with Emacs 30)
  (setq treesit-language-source-alist
        '((javascript "https://github.com/tree-sitter/tree-sitter-javascript" "v0.23.1")
          (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "v0.23.2" "tsx/src")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "v0.23.2" "typescript/src")))

  (defun my-treesit-install-all-languages ()
    "Install all missing Tree-sitter grammars from `treesit-language-source-alist'."
    (interactive)
    (dolist (lang-source treesit-language-source-alist)
      (let* ((lang (car lang-source)))
        (unless (treesit-language-available-p lang)
          (treesit-install-language-grammar lang)))))

  (add-hook 'emacs-startup-hook #'my-treesit-install-all-languages)
#+END_SRC

*** Syntax Checking

I love having "squiggly lines" in my editor; I want to know about potential problems in my code /before/ I take the time to test it.  FlyCheck will utilize my ESLint installation to check my JavaScript for issues, and it will report any compilation errors from my TypeScript language server when I'm working with TypeScript.

For JavaScript, install and configure ESLint (=npm i -g eslint=), and enable =flycheck-mode= in =js-ts-mode=:

#+BEGIN_SRC elisp
  (add-hook 'js-ts-mode-hook #'flycheck-mode)
#+END_SRC

*** Jumping to Definitions

It's important to have an accurate understanding of the code you're working with; often, that involves tracing variables back to their source.  Using =Ctrl+F= to find a variable's definition can be time-consuming, and you need to be wary to disambiguate variables that are declared with the same name in multiple places.

For JavaScript, use the =js-ts-defs= package, which leverages Tree-sitter to identify /definitively/ where functions and variables are defined - at least within a single file.  (Shameless plug - I made this package!)

#+BEGIN_SRC elisp
  (require 'js)

  (define-key js-ts-mode-map (kbd "M-.") #'js-ts-defs-jump-to-definition)
#+END_SRC

For TypeScript, Tide provides intelligent jump-to-definition.  It understands how TypeScript compiles code, and can thus follow imports across files.  No additional configuration is needed - it works out-of-the-box once Tide is set up.

With these configured, you can place your cursor on any function or variable name and press =Alt+.= to jump to where it's defined.  Press =Alt+,= to jump back to where you were.

*** TypeScript Language Server

For TypeScript, use the Tide package, which provides deep integration with the TypeScript language server.  Tide handles both syntax checking and intelligent code completion.  It also integrates with ElDoc mode, which displays function signatures and documentation in the minibuffer as you type.  You can also chain Tide's TypeScript checker with ESLint, unlocking additional code quality feedback that TypeScript may not provide:

#+BEGIN_SRC elisp
  (require 'tide)
  (require 'company)

  (defun my-setup-tide ()
    (tide-setup)
    (flycheck-mode)
    (eldoc-mode)
    (company-mode))

  (add-hook 'typescript-ts-mode-hook #'my-setup-tide)
  (add-hook 'tsx-ts-mode-hook #'my-setup-tide)

  ;; Check TypeScript, then ESLint
  (flycheck-add-next-checker 'typescript-tide 'javascript-eslint)
  (flycheck-add-next-checker 'tsx-tide 'javascript-eslint)
#+END_SRC

*** Autocompletion

Tide (covered above) provides intelligent autocompletion for TypeScript via Company mode.  Company will suggest completions as you type, showing available properties, methods, and type information.

For basic JavaScript projects without TypeScript, you can use a simpler autocomplete solution.  The =auto-complete= package provides text-based completions that work across all programming modes:

#+BEGIN_SRC elisp
  (require 'auto-complete)

  (global-auto-complete-mode t)
  (add-to-list 'ac-modes 'js-ts-mode)
#+END_SRC

In both modes, you use =TAB= to accept any completions.

*** Snippets

YASnippet is a template system that lets you quickly insert common code patterns.  Press =Ctrl+TAB= to be prompted with a list of snippets, choose one with Ido-powered fuzzy matching, then =Ctrl+TAB= through any placeholders to fill in the chosen template.

#+BEGIN_SRC elisp
  (require 'yasnippet)

  ;; Store snippets in your config directory
  (setq yas-snippet-dirs `(,(concat user-emacs-directory "Snippets")))

  (yas-reload-all)

  ;; Use Ctrl+Tab to choose snippets (avoiding conflicts with other tab uses)
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (define-key yas-minor-mode-map (kbd "<C-tab>") #'yas-insert-snippet)

  ;; Also use Ctrl+Tab to fill in placeholders (Tab could trigger completions)
  (define-key yas-keymap [(tab)] nil)
  (define-key yas-keymap (kbd "TAB") nil)
  (define-key yas-keymap (kbd "<C-tab>") #'yas-next-field-or-maybe-expand)

  (add-hook 'prog-mode-hook #'yas-minor-mode)
  (add-hook 'org-mode-hook #'yas-minor-mode)

  ;; Helper used by snippets:
  (defun my-escape-single-quotes (str)
    (replace-regexp-in-string "'" "\\\\'" str))
#+END_SRC

Ordinarily, YASnippet users type out a snippet name /first/ and then use =TAB= to expand it.  However, I don't use snippets as often as I accept autocomplete suggestions, which I also bind to =TAB=, and I've found that overloading my keys can cause annoying conflicts; thus, I chose to use =Ctrl-TAB= to expand snippets, instead.  Also, I prefer to be prompted with all my snippet names and to fuzzy-match my way to a choice; I could never remember the terse names I used to assign to my snippets to make them "easy" to expand.  Fuzzy matching implicitly reduces typing.

I've included several useful snippets for debugging JavaScript code:

- =import util= - Imports Node's =util= module
- =inspect object= - Uses =util.inspect()= to log an object fully, since Node's =console.log= will sometimes omit properties or truncate large amounts of data
- =log expression= - Inserts =console.log('DEBUG <expression>', <expression>)= where the expression name is automatically populated.  This makes it easy to see both what you're logging and its value.  A "DEBUG" keyword makes the message easy to filter.
- =stack trace= - Generates a stack trace at the current point in your code without throwing an error.  Useful for understanding how you got to a particular line of code.

TypeScript inherits all the JavaScript snippets, extending them with proper type annotations where necessary.

** Writing with Org Mode

Org mode is Emacs' native format for structured documents.  I like using it for note-taking, maintaining my many "to-do" lists, and for preparing documentation (like this guide!)

I recommend enabling =visual-line-mode= here so paragraphs flow like in a normal document, rather than extend outside the frame.

#+BEGIN_SRC elisp
  (add-hook 'org-mode-hook #'visual-line-mode)
#+END_SRC

*** Generating Previews

Org files can be exported to HTML.  After making some tweaks to the default settings, I found the formatting that Emacs uses to be pleasant-to-read.

Here's a function that previews your exported Org file in your default web browser (triggered by =Ctrl+P=):

#+BEGIN_SRC elisp
  (require 'ox) ; org export

  ;; Disable messy export settings
  (setq org-export-with-toc nil)
  (setq org-export-with-section-numbers nil)
  (setq org-export-with-author nil)
  (setq org-export-time-stamp-file nil)
  (setq org-html-validation-link nil)

  (defun my-org-preview ()
    (interactive)
    (browse-url-of-buffer
     (let ((org-export-show-temporary-export-buffer nil))
       (org-html-export-as-html))))

  (define-key org-mode-map (kbd "C-p") #'my-org-preview)
#+END_SRC

*** Org Mode Snippets

YASnippet works great with Org mode too!  Here are the included snippets:

- =preamble= - Quickly insert a document header with title and author fields
- =src block= - Insert a source code block with syntax highlighting

These snippets make it easier to create well-formatted Org documents.  (I often struggled to remember the exact syntax for these oft-used constructs.)

** Missing Modes

I feel like anyone who's working on software projects will benefit from having support for a few more common file formats, noticeably-absent in the default Emacs distribution.

*** Markdown

It seems like most "README" files are written in this format, these days.

Like with Org mode, I recommend enabling =visual-line-mode= so text flows naturally within your frame:

#+BEGIN_SRC elisp
  (require 'markdown-mode)
  (add-hook 'markdown-mode-hook #'visual-line-mode)
#+END_SRC

*** YAML

A really common config file format, used for things like GitHub Actions and much more.

#+BEGIN_SRC elisp
  (require 'yaml-mode)
#+END_SRC

*** Git Configuration Files

Everyone uses Git!!  Make =.gitignore= and similar files pretty.

#+BEGIN_SRC elisp
  (require 'git-modes)
#+END_SRC

* What's Mine is Yours

Like what you've read about here?  I went ahead and packaged up all my essential configs - everything covered in this document - into a handy "starter config" that you can download and use to initialize your own Emacs installation.

To get started, copy these files/directories to your =~/.emacs.d/= directory:

- =init.el= - The main configuration file
- =Snippets/= - The complete snippets directory with all the JavaScript, TypeScript, and Org mode snippets

If there's anything you want to add, change, or remove about my config, then go for it!  You have your own copy now and you can make it your own.  Or, start from scratch, like I did, and pull in whatever bits of mine that you like.
