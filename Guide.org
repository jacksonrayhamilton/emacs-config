#+title: Guide to Emacs: An Editor for a Lifetime
#+author: Jackson Ray Hamilton

* Making My Own Kitchen Sink

Emacs, and its packages, provide a more-or-less comprehensive suite of tools for editing text - and ultimately, for building projects and producing code.  However, it's not all plug-and-play; in this ecosystem, there are lots of settings you need to tweak and tools you need to discover, install, and master, in order to craft an experience that's best for you.  What you'll have by the end of your customization journey is a "kitchen sink" - a workspace in which you can effortlessly navigate codebases and maintain them.  That's what I feel I've achieved over the last decade+ of using Emacs.

What follows are all the tips and tricks I have for anyone who wants to learn and master this awesome tool.  Everything here you can copy into your own config file, which can be saved to: =~/.emacs.d/init.el=

A working config file implementing /all/ of this is also available in this directory; see "init.el"

* The Ins and Outs of My Configuration

** Theme and Appearance

Out-of-the-box, GUI builds of Emacs look hideous.  However, with a few simple steps, I believe Emacs can be made to look "cool:"

- Disable unnecessary UI elements, like the toolbar and scrollbar
- Configure a font that is both readable and beautiful
- Override the default theme with a stylish dark theme, incorporating iconography

For the font, I love Monaco on a Mac.  A size of "16" accomodates my failing eyesight.

The theme I've been satisfied with for the past few years has been =zerodark-theme=.  Note that you need to run the command =all-the-icons-install-fonts= (once) to install the iconography for =zerodark-theme= at the system level.

*** Config

#+BEGIN_SRC elisp
  (setq inhibit-splash-screen t)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)

  (defconst my-default-font
    (cond
     ((eq system-type 'darwin)
      "monaco 16")
     ((eq system-type 'windows-nt)
      "consolas 16")
     (t
      "monospace 16")))

  (set-frame-font my-default-font)
  (add-to-list 'default-frame-alist `(font . ,my-default-font))

  (load-theme 'zerodark t)
  (zerodark-setup-modeline-format)
#+END_SRC

** Standardization

I no longer use Emacs' (crazy) default keymap.  (The one described in the Emacs tutorial.)  It was fun to learn initially, but not to use regularly.  The rest of my OS uses "normal" bindings, and I believe my editor should behave the same.

Enabling =cua-mode= normalizes a few common editing shortcuts:

- =Ctrl+Z= to undo
- =Ctrl+X= to cut
- =Ctrl+C= to copy
- =Ctrl+V= to paste

The remaining shortcuts that I'd consider "standard" - and especially-useful for everyday editing - need to be configured manually:

- =Ctrl+A= to "select all"
- =Ctrl+O= to open files
- =Ctrl+B= to switch buffers (i.e. switch between files)
- =Ctrl+S= to save
- =Ctrl+W= to close a buffer (i.e. a file)
- =Ctrl+F= to search
- =Ctrl+R= to find and replace

*** Config

#+BEGIN_SRC elisp
  (cua-mode)

  (keymap-global-set "C-a" #'mark-whole-buffer)
  (keymap-global-set "C-o" #'find-file)
  (keymap-global-set "C-b" #'switch-to-buffer)
  (keymap-global-set "C-s" #'save-buffer)
  (keymap-global-set "C-w" #'kill-current-buffer)
  (keymap-global-set "C-f" #'isearch-forward)
  (keymap-global-set "C-r" #'query-replace)
#+END_SRC

It frustrates me that Emacs puts itself out-of-reach to anyone except highly-patient adepts willing to learn its strange default keymap, or else to those with the motivation to learn how to fix it.  Thankfully, it only takes a few lines of config to resolve this discomfort and make Emacs "feel like home."

Also, I recommend remapping your "Caps Lock" key to an additional =Ctrl= at the OS level.  It's a big, unimportant key, which is often a lot easier to press than the actual "Control" key on a keyboard, as far as all these keyboard shortcuts are concerned.

** Navigation

*** Buffers

To move around buffers (i.e. files), I alternate between the following methods:

- Trackpad/mouse
- The four arrow keys (sometimes with =Alt=, i.e. =Option= on Mac, to skip over words)
- =Alt+M= to jump to where indentation begins (usually more useful than beginning-of-line)
- =Ctrl+E= to jump to end-of-line
- =Alt+<= (i.e. =Alt+Shift+,=) to jump to beginning-of-file
- =Alt+>= (i.e. =Alt+Shift+.=) to jump to end-of-file
- =Ctrl+F=

Besides =Ctrl+F=, these are all default bindings - no config necessary.

*** Files

To open files, I alternate between the following methods:

- =Ctrl+B= to select an already-open file
- =Ctrl+O= to select a file from the filesystem
- =Ctrl+/= to list files (=ls -la=) and open from the list

Emacs offers a text-based, interactive view of your filesystem, similar to =ls -la= in Mac/Linux shells.  It's accessible via "Dired" using =dired-jump=, which I have bound to =Ctrl+/=.  (Mnemonic: "/" is the character used to denote "directory" in Mac/Linux, and you're "opening the directory.")

#+BEGIN_SRC elisp
  (keymap-global-set "C-/" #'dired-jump)
#+END_SRC

I prefer Dired to a "tree view" because I can focus on one directory at a time, then close the view.

As I use Emacs, I tend to have a large number of files open at a time.  Instead of managing tabs (neverending clutter), Emacs invisibly manages a list of my open files for me.  I allow my list of open files to grow for a while, and I use fuzzy matching to quickly narrow and select from this large list via a compact view, "Ido."

Ido ("interactive do") is a user-friendly interface that can be enabled for selecting files in Emacs.  It is enhanced by the packages =ido-completing-read+= (enabling Ido "everywhere" in Emacs) and =flx-ido= (enabling fuzzy matching).

#+BEGIN_SRC elisp
  (require 'ido)
  (ido-mode 1)
  (ido-everywhere 1)
  (ido-ubiquitous-mode 1)
  (flx-ido-mode 1)
  (setq ido-enable-flex-matching t)
  (setq ido-use-faces nil) ; disable ido faces to see flx highlights
  (setq gc-cons-threshold 20000000) ; recommended for better GC with flx
#+END_SRC

** Text Selection

In Emacs you can select text with your trackpad/mouse, or by setting mark with =Ctrl+SPACE= and moving point with keyboard commands to manually create a region.

There is also a package you can install called =expand-region= which can help you to automatically select text by semantic units.  I highly-recommend it as it takes much of the precision work out of selecting text.

- =Ctrl+== to create or expand a selection from your current position
- =Ctrl+PLUS= (i.e. =Ctrl+Shift+==) to contract selection

*** Config

#+BEGIN_SRC elisp
  (keymap-global-set "C-=" #'er/expand-region)
  (keymap-global-set "C-+" #'er/contract-region)
#+END_SRC

** Search

Often I want to search for additional instances of a bit of text that's in a file.  Here's some config to make it so that, if you use =Ctrl+F= while you have some text selected, then the selected text is what gets searched-for.  (Works really well with =expand-region=.)

#+BEGIN_SRC elisp
  (defun my-isearch-with-region ()
    "Use region as the isearch text."
    (when mark-active
      (let ((region (funcall region-extract-function nil)))
        (deactivate-mark)
        (isearch-push-state)
        (isearch-yank-string region))))

  (add-hook 'isearch-mode-hook #'my-isearch-with-region)
#+END_SRC

** Screen Splitting

Emacs has commands to "split screens," which it refers to as "windows."  I like to bind these to =Ctrl+NUMBER=:

- =Ctrl+0= to "minimize" the current window (likely maximizing another)
- =Ctrl+1= to maximize the current window (if there's a split)
- =Ctrl+2= to split vertically
- =Ctrl+3= to split horizontally

The mnemonic here is:

- =Ctrl+0=: "reduce to nothing (0)"
- =Ctrl+1=: "make it the only one (1)"
- =Ctrl+2=: "split it in two (2)"
- =Ctrl+3=: like =Ctrl+2=, but the "other" variant

You can split screens an arbitrary number of ways, but I usually either have a single window maximized at a time, or temporarily have the screen split into two parts vertically.  A horizontal split is occasionally more useful depending on the format of the documents you have open.

*** Config

#+BEGIN_SRC elisp
  (keymap-global-set "C-0" #'delete-window)
  (keymap-global-set "C-1" #'delete-other-windows)
  (keymap-global-set "C-2" #'split-window-below)
  (keymap-global-set "C-3" #'split-window-right)
#+END_SRC

** Quick Access Shortcuts

From =F5= through =F9=, Emacs provides no default bindings.  I decided to make this range of keys my "command center" for my most-frequently-used and most-powerful commands.

If you use a Mac, you can make it so you don't need to press =fn= to trigger your =F= keys, like normal.  I'd recommend enabling that setting, as the shortcuts will be much more ergonomic.

*** F5: Open Emacs Config File

Since the beauty of Emacs is in customizing the experience to your liking, you frequently find yourself opening and editing your config file.  I opened it so often that I decided to just dedicate a special key to it.  (Surprised?)

#+BEGIN_SRC elisp
  (defun my-find-configuration ()
    "Open the Emacs configuration file."
    (interactive)
    (find-file (concat user-emacs-directory "init.el")))

  (keymap-global-set "<f5>" #'my-find-configuration)
#+END_SRC

*** F6: Restart Emacs

Whenever you update your config file, you have the option to either manually evaluate the Lisp forms therein to apply the configuration changes directly to the current instance - OR, you can simply restart Emacs, and all the forms will be evaluated "freshly."  Often, testing configuration changes is easiest with a quick restart.

Emacs has a built-in command called =restart-emacs=, but I recommend installing the 3rd-party package with the same name.  It provides a version of the command that seems to work more reliably than the built-in one.

#+BEGIN_SRC elisp
  (require 'restart-emacs) ; load 3rd-party version

  (defun my-restart ()
    "Prompt whether to restart Emacs."
    (interactive)
    (when (y-or-n-p "Restart?")
      (restart-emacs)))

  (keymap-global-set "<f6>" #'my-restart)
#+END_SRC

*** F7: Git Interface

Emacs is blessed with a very powerful and user-friendly interface to Git called "Magit."  Magit makes working with Git much easier than the standard command-line interface, and without any noticeable sacrifices in functionality.  I consider Magit one of the most important tools in my toolbelt during a day dedicated to coding.

With Magit, all Git commands have 1-letter shortcuts, making them painless to invoke:

- =F7= to see changes and invoke other commands
- =TAB= to toggle diffs
- =s= to stage files/hunks
- =A= to cherry-pick
- =b= to branch
- =c= to commit
- =F= to pull
- =l= to view commit log
- =P= to push
- =r= to rebase
- =V= to revert
- =z= to stash

Magit can also be combined with Ido for easy access to all branch and tag names (for when you need to switch to them).  Use the package =magit-ido= for that integration.

#+BEGIN_SRC elisp
  (require 'magit)
  (require 'magit-ido)

  (keymap-global-set "<f7>" #'magit-status)
  (setq magit-completing-read-function #'magit-ido-completing-read)
#+END_SRC

*** F8: Project Management

When working on a software project, it's common to search for files and text within the scope of a project's root directory - as opposed to from the scope of the whole filesystem, or from miscellaneous subdirectories.  Sometimes you may also wish to "find and replace" across files in a project.

The Emacs package "Projectile" automatically detects the root directory of the project associated with any file you have open, and then it performs searches from there.  The package can also be configured to filter out uninteresting files/directories from searches; simply create a =.projectile= file in the project root, and list filename patterns to ignore.

I prefer Projectile's "dynamic project actions" to the model of "opening a project" seen in other editors.  Other editors lock you into editing one project per editor instance; however, in my experience, it's common to hop between projects, especially those that depend on each other.  Having a single editor instance to manage multiple projects at once feels convenient.

Like Magit, Projectile provides a suite of 1-letter shortcut keys to perform its various operations:

- =F8= to choose a project-based command
- =f= to find a file by name within the project
- =g= to search the project's files with Grep
- =r= to find and replace, interactively, file-by-file

#+BEGIN_SRC elisp
  (projectile-mode)

  (keymap-global-set "<f8>" #'projectile-commander)
#+END_SRC

*** F9: AI Assistant

All of Emacs' functionality aids programmers in the authorship of formal languages.  It remains important that there are tools available for exploring directories and examining files, as well as for precisely editing and quickly searching.

However, AI coding assistants have become impressively-capable of converting natural languages into code, massively reducing the levels of manual exploration, examination, editing, and searching required to create working applications.  It's becoming obvious to more and more developers that LLMs are one of the most convenient and powerful tools now available, in terms of understanding, planning, templating, and debugging.

Claude Code is my coding assistant of choice.  I was very happy with the results from Anthropic's Sonnet model, and Claude Code utilizes Sonnet beautifully.  I use it to write most of my code and to plan and implement most of the changes I make.  The integrations with Linear and Figma also enable the tool to automatically implement most product requirements as specified by my teammates at work.

I use =claude-code.el= (by Steve Molitor) in order to manage Claude Code instances inside Emacs on a per-project basis.  Like Magit and Projectile, =claude-code.el= provides a suite of 1-letter shortcut keys to help me interact with Claude Code:

- =F9= to choose a command
- =c= to start the assistant
- =t= to open and switch to the assistant's window
- =z= to enable "read-only" mode in the assistant window (navigate/select output)

#+BEGIN_SRC elisp
  (require 'claude-code)

  (setq claude-code-toggle-auto-select t)
  (setq claude-code-eat-read-only-mode-cursor-type '(bar nil nil))

  (keymap-global-set "<f9>" #'claude-code-transient)
#+END_SRC

*** Other Commands

All of Emacs' commands are available explicitly via =Alt+X=.  For any commands that couldn't fit into the command center, access them here.  Ido completion is available here via the =ido-completing-read+= package, but there is also a further enhancement available via the =amx= package, which will sort your most-used commands to the front of the completions, as well as display any keybindings for the listed commands.

#+BEGIN_SRC elisp
  (amx-mode 1)
#+END_SRC

** Coding with JavaScript/TypeScript

JavaScript and TypeScript are the languages I write the most code in.  My setup for those languages is the most-sophisticated and battle-tested one that I can showcase.

Modern Emacs includes tree-sitter support, which provides fast and accurate syntax highlighting and automatic indentation for JavaScript and TypeScript.  I recommend remapping the default mode for JavaScript to the tree-sitter variant.  For TypeScript, Emacs /only/ comes with tree-sitter variants (TS & TSX), but they're not enabled by default.

#+BEGIN_SRC elisp
  (add-to-list 'major-mode-remap-alist '(javascript-mode . js-ts-mode))

  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . tsx-ts-mode))
#+END_SRC

Also, once, you will need to install the grammars for each of these modes.  You will need a C/C++ compiler and linker installed in order to do this.  The following code will try to download and compile the grammars the first time you open Emacs.  If you run into errors, and want to try again, then either restart Emacs, or manually invoke the command =my-treesit-install-all-languages= (via =Alt+X=).

#+BEGIN_SRC elisp
  (require 'treesit)

  ;; (Compatible with Emacs 30)
  (setq treesit-language-source-alist
        '((javascript "https://github.com/tree-sitter/tree-sitter-javascript" "v0.23.1")
          (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "v0.23.2" "tsx/src")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "v0.23.2" "typescript/src")))

  (defun my-treesit-install-all-languages ()
    "Install all missing Tree-sitter grammars from `treesit-language-source-alist'."
    (interactive)
    (dolist (lang-source treesit-language-source-alist)
      (let* ((lang (car lang-source)))
        (unless (treesit-language-available-p lang)
          (treesit-install-language-grammar lang)))))

  (add-hook 'emacs-startup-hook #'my-treesit-install-all-languages)
#+END_SRC

*** Syntax Checking

Flycheck is an excellent on-the-fly syntax checker for Emacs.  It integrates with linters like ESLint for JavaScript, and can use the TypeScript compiler itself to check TypeScript code.

For JavaScript, simply enable =flycheck-mode= in =js-ts-mode=:

#+BEGIN_SRC elisp
  (require 'flycheck)

  (defun my-javascript-mode-hook ()
    (flycheck-mode))

  (add-hook 'js-ts-mode-hook #'my-javascript-mode-hook)
#+END_SRC

*** Jumping to Definitions

Being able to quickly jump to a function or variable's definition is essential when navigating large codebases.  The standard Emacs keybinding for this is =Alt+.=.

For JavaScript, use the =js-ts-defs= package, which leverages tree-sitter to find definitions within the current file:

#+BEGIN_SRC elisp
  (require 'js)

  (define-key js-ts-mode-map (kbd "M-.") #'js-ts-defs-jump-to-definition)
#+END_SRC

For TypeScript, Tide automatically provides intelligent jump-to-definition that understands TypeScript's type system and can follow imports across files.  No additional configuration is needed - it works out-of-the-box once Tide is set up.

With these configured, you can place your cursor on any function or variable name and press =Alt+.= to jump to where it's defined.  Press =Alt+,= to jump back to where you were.

*** TypeScript Language Server

For TypeScript, use the Tide package, which provides deep integration with the TypeScript language server.  Tide handles both syntax checking and intelligent code completion.  It also integrates with ElDoc mode, which displays function signatures and documentation in the minibuffer as you type.  You can also chain Tide's TypeScript checker with ESLint:

#+BEGIN_SRC elisp
  (require 'tide)
  (require 'company)

  (defun my-setup-tide ()
    (tide-setup)
    (flycheck-mode)
    (eldoc-mode)
    (company-mode))

  (add-hook 'typescript-ts-mode-hook #'my-setup-tide)
  (add-hook 'tsx-ts-mode-hook #'my-setup-tide)

  ;; Check TypeScript, then ESLint
  (flycheck-add-next-checker 'typescript-tide 'javascript-eslint)
  (flycheck-add-next-checker 'tsx-tide 'javascript-eslint)
#+END_SRC

*** Autocompletion

Tide (covered above) provides intelligent autocompletion for TypeScript via Company mode.  Company will suggest completions as you type, showing available properties, methods, and type information.

For basic JavaScript projects without TypeScript, you can use a simpler autocomplete solution.  The =auto-complete= package provides text-based completions that work across all programming modes:

#+BEGIN_SRC elisp
  (require 'auto-complete)

  (global-auto-complete-mode t)
  (add-to-list 'ac-modes 'js-ts-mode)
#+END_SRC

*** Snippets

YASnippet is a template system that lets you quickly insert common code patterns.  Type an abbreviation and press =Ctrl+TAB= to expand it into a full snippet, then tab through the placeholders to fill them in.

#+BEGIN_SRC elisp
  (require 'yasnippet)

  ;; Store snippets in your config directory
  (setq yas-snippet-dirs `(,(concat user-emacs-directory "Snippets")))

  (yas-reload-all)

  ;; Use Ctrl+Tab to expand snippets (avoiding conflicts with other tab uses)
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (define-key yas-minor-mode-map (kbd "<C-tab>") #'yas-insert-snippet)

  ;; Enable snippets in programming modes
  (add-hook 'prog-mode-hook #'yas-minor-mode)
#+END_SRC

Create a =Snippets/js-ts-mode= directory in your =~/.emacs.d/= folder to store JavaScript snippets, and a =Snippets/typescript-ts-mode= directory for TypeScript snippets.  Each snippet is a small text file with special placeholders.

** Writing with Markdown and Org

Emacs supports both Markdown and Org Mode for writing documentation, notes, and other long-form text.  Both modes benefit from visual line wrapping, which makes prose easier to read and edit by wrapping lines at word boundaries instead of at a fixed column width.

*** Markdown

Markdown mode provides syntax highlighting and editing commands for Markdown files.  Enabling =visual-line-mode= ensures text wraps naturally as you resize the window.

#+BEGIN_SRC elisp
  (add-hook 'markdown-mode-hook #'visual-line-mode)
#+END_SRC

*** Org Mode

Org mode is Emacs' native format for structured documents.  It's incredibly powerful, supporting everything from simple note-taking to complex project planning and literate programming.  For basic writing, it's similar to Markdown but with more features.

#+BEGIN_SRC elisp
  (add-hook 'org-mode-hook #'visual-line-mode)
#+END_SRC

*** Generating Previews

Both Markdown and Org files can be previewed as HTML in your browser.  This is useful for seeing how your document will look when rendered, especially if you're writing documentation that will be published online.

For Markdown, install the =marked= command-line tool (=npm i -g marked=), then configure Emacs to use it:

#+BEGIN_SRC elisp
  (require 'markdown-mode)

  ;; Set the markdown preview command
  (setq markdown-command "marked")

  ;; Bind Ctrl+P to preview
  (define-key markdown-mode-map (kbd "C-p") #'markdown-preview)
#+END_SRC

For Org mode, Emacs has built-in HTML export functionality.  Here's a function that exports your Org file to HTML and opens it in your browser:

#+BEGIN_SRC elisp
  (require 'ox) ; org export

  (defun my-org-preview ()
    (interactive)
    (browse-url-of-buffer
     (let ((org-export-show-temporary-export-buffer nil))
       (org-html-export-as-html))))

  (define-key org-mode-map (kbd "C-p") #'my-org-preview)
#+END_SRC

In both modes, press =Ctrl+P= to preview your document in your default web browser.

* What's Mine is Yours

Like what you've read about here?  I went ahead and packaged up all my essential configs - everything covered in this document - into a handy "starter config" that you can download and use to initialize your own Emacs installation.  It's right here in this directory: "init.el"

If there's anything you want to add, change, or remove about my config, then go for it!  You have your own copy now and you can make it your own.  Or, start from scratch, like I did, and pull in whatever bits of mine that you like.
